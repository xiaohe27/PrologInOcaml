(*
 * File: mp7-skeleton.ml
 *)

open Mp7common

(* Problem 1*)
let asMonoTy1 () = mk_fun_ty bool_ty (mk_list_ty int_ty);;
let asMonoTy2 () = let alpha=TyVar 0 in let beta=TyVar 1 in let delta=TyVar 2 in let gemma=TyVar 3 in
			 mk_fun_ty alpha (mk_fun_ty beta (mk_fun_ty delta gemma));;
 
let asMonoTy3 () = let alpha=TyVar 0 in let beta=TyVar 1 in 
			mk_fun_ty alpha (mk_list_ty (mk_pair_ty beta int_ty)) ;;

let asMonoTy4 () = let beta=TyVar 0 in let alpha=TyVar 1 in
			mk_pair_ty string_ty (mk_fun_ty (mk_list_ty beta) alpha);;

(* Problem 2*)
let rec subst_fun subst = fun tyVar -> match subst with
				[] -> TyVar tyVar |
				(ty, replace)::xs -> if tyVar = ty then replace 
							else subst_fun xs tyVar;;

(* Problem 3*)

let rec monoTy_lift_subst subst monoTy = match subst with 
					[] -> monoTy |
				_ -> match monoTy with 
					TyVar tvar -> subst_fun subst tvar |
					TyConst (op, tyList) -> match tyList with
						[] -> TyConst (op, []) |
						_ -> let updatedTyList= monoTy_lift_subst_list subst tyList
						in TyConst (op, updatedTyList) and
	monoTy_lift_subst_list subst tyList = match tyList with
						[] -> [] |
						h::t -> (monoTy_lift_subst subst h) :: 
							(monoTy_lift_subst_list subst t) ;;






(* Problem 4*)
let rec occurs x ty = match ty with 
			TyVar y -> (x = y) |
			TyConst(op, tyList) -> occursInList x tyList 
			and occursInList x tyList = match tyList with
				[] -> false |
				h::t -> if (occurs x h) then true else
					occursInList x t;;



let rec occursInSndPartOfSubst x sigma = match sigma with 
						[] -> false |
						(k,v)::tail -> if occurs x v then true 
								else occursInSndPartOfSubst x tail;;

(* Problem 5*)

(* helper function 1 *)
let rec monoTy_lift_subst_pair_list subst pairList= match pairList with
							[] -> [] |
							(mt1, mt2) :: tail -> (monoTy_lift_subst subst mt1,
									       monoTy_lift_subst subst mt2) 
								:: monoTy_lift_subst_pair_list subst tail;;
(* helper function 2 *)
let rec updateSubst sigma substList = match substList with 
						[] -> Some [] |
						(x, mt)::tail -> if occursInSndPartOfSubst x sigma then None 
								else								 
								match (updateSubst sigma tail) with
									None -> None |
									Some tailResultList -> Some ((x, monoTy_lift_subst sigma mt) :: tailResultList);;

let rec updateListWithElement lst (key, value)= match lst with
						[] -> [(key, value)] |
						(k, v)::tail -> 
							if k=key then (updateListWithElement tail (key, value)) 
							else (k, v):: (updateListWithElement tail (key, value));; 

let rec updateListWithList newList oldList = match newList with 
						[] -> oldList |
						keyValPair :: tail -> updateListWithList tail (
						updateListWithElement oldList keyValPair);;

let rec composeSubst sigma substList = match substList with 
						[] -> Some sigma |
						(x, mt)::tail -> 
							match (updateSubst sigma substList) with
								None -> None |
								Some sigma2 ->
							Some (updateListWithList sigma2 sigma);;


(* helper function 3 *)
let rec genPairList list1 list2 = if (List.length list1 != List.length list2) 
					then None
				   else match (list1, list2) with 
					([],_) -> Some [] |
					(_, []) -> Some [] | 
					(h1::t1, h2::t2) -> let tailR=genPairList t1 t2 in
						match tailR with None -> None |
							Some tailResultList ->
								Some ((h1,h2)::tailResultList);;

let rec unify eqlst = match eqlst with 
			[] -> Some [] |
			(s,t)::eqlst' -> (
				if s = t then unify eqlst'
				else (match (s,t) with 
					(TyConst(_,_), TyVar _) -> (unify ((t,s)::eqlst')) |
					(TyConst(f1, tyList1), TyConst(f2, tyList2) ) -> (
						if f1 = f2 then (
						let pairList= (genPairList tyList1 tyList2) 
						 in (match pairList with 
							None -> None |
							Some newConstraints -> unify (eqlst' @ newConstraints)	)
						

) else (None) ) 

|	(TyVar x, _) -> (if (occurs x t) then (None)
			else (let eqlst''= monoTy_lift_subst_pair_list ([(x,t)]) eqlst' in
				let sigmaResult= unify eqlst'' in
					match sigmaResult with 
						None -> None |
						Some sigma ->

				let sigma2= [(x, monoTy_lift_subst sigma t)] in
					
					match (composeSubst sigma2 sigma) with
						None -> None |
						Some finalResult -> Some finalResult ) ) 

|	_ -> (None)
				
));;







(* Extra Credit *)
let rec rev_sig subst= raise (Failure "not implemented yet");;








